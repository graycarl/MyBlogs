<!DOCTYPE html>
<html lang="zh">
<head>
        <title>Bash持续积累 - I am HHB</title>
        <meta charset="utf-8" />

        <!-- UIKIT -->
        <link href="http://cdn.bootcss.com/uikit/2.0.0/css/uikit.min.css" rel="stylesheet">
        <script src="http://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>
        <script src="http://cdn.bootcss.com/uikit/2.0.0/js/uikit.min.js"></script>
        <!-- MyCSS -->
        <link rel="stylesheet/less" type="text/css" href="/theme/css/hhb-uikit.less">
        <link rel="stylesheet/less" type="text/css" href="/theme/css/code.css">
        <script src="http://cdn.bootcss.com/less.js/1.6.0/less.min.js"></script>
        <link href="http://fonts.googleapis.com/css?family=Nova+Script|Racing+Sans+One" rel="stylesheet" type="text/css">
        <!-- FEEDS -->
</head>

<body>
    <header class="hhb-banner">
        <hgroup>
            <h1 class="uk-heading-large"><a href="/">I am HHB</a></h1>
            <p>月亮哪去了</p>
        </hgroup>
    </header>
    <nav class="uk-navbar hhb-navbar">
        <ul class="uk-navbar-nav">
            <li><a href="/category/articles.html">Articles</a></li>
            <li><a href="/category/life.html">Life</a></li>
            <li class="uk-active"><a href="/category/notes.html">Notes</a></li>
        </ul>
        <!--
        <div class="uk-navbar-content uk-navbar-flip">
            <form class="uk-form uk-margin-remove uk-display-inline-block" action="">
                <input type="text" placeholder="Search" />
            </form>
        </div>
        -->
    </nav>

    <div class="hhb-content">
<article class="uk-article">
    <header>
        <h1 class="uk-article-title">
            <a class="hidden" href="/bash-notes.html" rel="bookmark"
                title="Permalink to Bash持续积累">Bash持续积累</a>
        </h1>
        <p class="uk-article-meta">Hongbo He · <abbr title="2012-08-24T03:25:00+08:00">2012-08-24 03:25</abbr></p>
        
    </header>
    <div class="entry-content">
        <h2>条件判断</h2>
<p><strong>语法</strong>,可以用<code>[ -e /tmp/tf1 ]</code>或者<code>test -e /tmp/tf1</code>。</p>
<h3>文件类型判断</h3>
<div class="highlight"><pre><span></span>-e    判断文件是否存在
-f    判断该文件是否存在且是一个文件(file)
-d    判断该文件是否存在且是一个目录(directory)
-b    判断该文件是否存在且是块设备
-c    判断该文件是否存在且是字符设备
-S    判断该文件是否存在且是一个Socket
-p    判断该文件是否存在且是一个管道文件(pipe)
-L    判断该文件是否存在且是一个软链接
</pre></div>


<h3>文件权限判断</h3>
<div class="highlight"><pre><span></span>-r    判断该文件是否存在且具有可读权限
-w    判断该文件是否存在且具有可写权限
-x    判断该文件是否存在且具有可执行权限
</pre></div>


<h3>文件比较，例如<code>test file1 -nt file2</code>。</h3>
<div class="highlight"><pre><span></span>-nt   判断file1是否比file2新
-ot   判断file1是否比file2旧
-ef   判断file1和file2是否为同一文件（用在判断hard link时）
</pre></div>


<h3>数值比较，只能用于整数。例如<code>test n1 -eq n2</code>。</h3>
<div class="highlight"><pre><span></span>-eq   判断n1是否等于n2
-ne   判断n1是否不等于n2
-gt   判断n1是否大于n2
-lt   判断n1是否小于n2
-ge   判断n1是否大于等于n2
-le   判断n1是否小于等于n2
</pre></div>


<h3>字符串判断</h3>
<div class="highlight"><pre><span></span>test -z string    判断string为空
test -n string    判断string不为空
test str1 = str2  判断str1等于str2
test str1 != str2 判断str1不等于str2
</pre></div>


<h3>逻辑运算</h3>
<div class="highlight"><pre><span></span>-o    逻辑或，例如 test -e file1 -o -e file2
-a    逻辑与，例如 test -e file1 -a -e file2
!     逻辑非，例如 test ! -e file1
</pre></div>


<h2>find</h2>
<p>基本用法，就是找某个名称的文件了。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39;
</pre></div>


<p>注意，这个name后面不是正则（以前一直以为这里是按正则来匹配的，所有总觉得用起来完全不对啊）。按man手册的说法，这里匹配的是"shell patter±？）。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39; | xargs -i mv {} {}.bak
</pre></div>


<p>这里用了-i这个参数，后面就可以用{}来代表每次xargs传过来的一个内容了。也就是说mv被调用了n次（n=找到的文件数）。</p>
<p>再有时候，我们希望xargs每次传两个参数给后面的命令来处理？没问题。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39; | xargs -n 2 diff
</pre></div>


<p>这样也行啊。不过，这样diff出来的东西是个啥？:)</p>
<p>Carl-MBPR:blogsite carl$ sqlite3 database/blogs.db 'select content from blogs where id=7;' &gt; /tmp/b
Carl-MBPR:blogsite carl$ sqlite3 database/blogs.db 'select content from blogs where id=6;' |tee /tmp/b</p>
<h2>条件判断</h2>
<p><strong>语法</strong>,可以用<code>[ -e /tmp/tf1 ]</code>或者<code>test -e /tmp/tf1</code>。</p>
<h3>文件类型判断</h3>
<div class="highlight"><pre><span></span>-e    判断文件是否存在
-f    判断该文件是否存在且是一个文件(file)
-d    判断该文件是否存在且是一个目录(directory)
-b    判断该文件是否存在且是块设备
-c    判断该文件是否存在且是字符设备
-S    判断该文件是否存在且是一个Socket
-p    判断该文件是否存在且是一个管道文件(pipe)
-L    判断该文件是否存在且是一个软链接
</pre></div>


<h3>文件权限判断</h3>
<div class="highlight"><pre><span></span>-r    判断该文件是否存在且具有可读权限
-w    判断该文件是否存在且具有可写权限
-x    判断该文件是否存在且具有可执行权限
</pre></div>


<h3>文件比较，例如<code>test file1 -nt file2</code>。</h3>
<div class="highlight"><pre><span></span>-nt   判断file1是否比file2新
-ot   判断file1是否比file2旧
-ef   判断file1和file2是否为同一文件（用在判断hard link时）
</pre></div>


<h3>数值比较，只能用于整数。例如<code>test n1 -eq n2</code>。</h3>
<div class="highlight"><pre><span></span>-eq   判断n1是否等于n2
-ne   判断n1是否不等于n2
-gt   判断n1是否大于n2
-lt   判断n1是否小于n2
-ge   判断n1是否大于等于n2
-le   判断n1是否小于等于n2
</pre></div>


<h3>字符串判断</h3>
<div class="highlight"><pre><span></span>test -z string    判断string为空
test -n string    判断string不为空
test str1 = str2  判断str1等于str2
test str1 != str2 判断str1不等于str2
</pre></div>


<h3>逻辑运算</h3>
<div class="highlight"><pre><span></span>-o    逻辑或，例如 test -e file1 -o -e file2
-a    逻辑与，例如 test -e file1 -a -e file2
!     逻辑非，例如 test ! -e file1
</pre></div>


<h2>find</h2>
<p>基本用法，就是找某个名称的文件了。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39;
</pre></div>


<p>注意，这个name后面不是正则（以前一直以为这里是按正则来匹配的，所有总觉得用起来完全不对啊）。按man手册的说法，这里匹配的是"shell pattern"。</p>
<p>进阶一点，就是找满足各种条件的文件了。</p>
<div class="highlight"><pre><span></span>find . -type d 找directory
             f 找plain file
             l 找symbolic link
             p 找named pipe file
             b 找block device
             c 找char device
find . -perm 755
find . -user carl
</pre></div>


<p>PS. 如果经常要在全局按文件名来找文件的话，强烈建议用<code>updatedb+locate</code>，<code>find / ...</code>实在太慢了。这两个命令在各个发行版下面对应的包可能都不同吧，自己找找好了。</p>
<h2>xargs</h2>
<p>处理批量作业时候最常用也是最好用的东西啊，大爱。</p>
<p>基本用法，就是把其标准输入的内容转变成它随后的命令的参数。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39; | xargs wc -l
</pre></div>


<p>这么一个简单的一行命令就可以统计该目录下所有c程序源码总行数了。</p>
<p>进阶一点，有时候，我们希望前面find找到的文件需要一个个的来处理。比如，对前面找到的所有c源码文件的文件名加个bak后缀（怎么会有这么诡异的需求？）。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39; | xargs -i mv {} {}.bak
</pre></div>


<p>这里用了-i这个参数，后面就可以用{}来代表每次xargs传过来的一个内容了。也就是说mv被调用了n次（n=找到的文件数）。</p>
<p>再有时候，我们希望xargs每次传两个参数给后面的命令来处理？没问题。</p>
<div class="highlight"><pre><span></span>find . -name &#39;*.[ch]&#39; | xargs -n 2 diff
</pre></div>


<p>这样也行啊。不过，这样diff出来的东西是个啥？:)</p>
    </div>
</section>
    </div>
    <hr/>
    <footer>
    <p>
    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
    </p>
    </footer>
    <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

</body>
</html>